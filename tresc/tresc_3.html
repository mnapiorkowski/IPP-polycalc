        <div id="page-content" class="row pb-3 d-print-block">
            <div id="region-main-box" class="col-12">

                <section id="region-main">
                    <div class="card">
                        <div class="card-body">
                            <span class="notifications" id="user-notifications"></span>
                            <div role="main"><span id="maincontent"></span><h2>Duże zadanie, część 3</h2><div id="intro" class="box py-3 generalbox boxaligncenter"><div class="no-overflow"><span class="filter_mathjaxloader_equation"><span class="nolink"><p>Celem trzeciej części zadania jest dokończenie programu kalkulatora działającego
na wielomianach rzadkich wielu zmiennych.
Oczekujemy poprawienia ewentualnych błędów z poprzednich części zadania oraz
wprowadzenie opisanych poniżej modyfikacji i rozszerzeń.
Obowiązują ustalenia z treści poprzednich części zadania i z forum dyskusyjnego
dla studentów.</p>

<h3>Konstruowanie wielomianu z tablicy jednomianów</h3>

<p>Do stworzonej w części 1 zadania biblioteki operacji na wielomianach <code>poly</code>
(pliki <code>poly.h</code> i <code>poly.c</code>) należy dodać dwie funkcje działające podobnie jak
funkcja <code>PolyAddMonos</code>, ale ze zmienionym sposobem przekazywania własności
tablicy jednomianów:</p>

<pre><code class="C">/**
 * Sumuje listę jednomianów i tworzy z nich wielomian. Przejmuje na własność
 * pamięć wskazywaną przez @p monos i jej zawartość. Może dowolnie modyfikować
 * zawartość tej pamięci. Zakładamy, że pamięć wskazywana przez @p monos
 * została zaalokowana na stercie. Jeśli @p count lub @p monos jest równe zeru
 * (NULL), tworzy wielomian tożsamościowo równy zeru.
 * @param[in] count : liczba jednomianów
 * @param[in] monos : tablica jednomianów
 * @return wielomian będący sumą jednomianów
 */
Poly PolyOwnMonos(size_t count, Mono *monos);
</code></pre>

<pre><code class="C">/**
 * Sumuje listę jednomianów i tworzy z nich wielomian. Nie modyfikuje zawartości
 * tablicy @p monos. Jeśli jest to wymagane, to wykonuje pełne kopie jednomianów
 * z tablicy @p monos. Jeśli @p count lub @p monos jest równe zeru (NULL),
 * tworzy wielomian tożsamościowo równy zeru.
 * @param[in] count : liczba jednomianów
 * @param[in] monos : tablica jednomianów
 * @return wielomian będący sumą jednomianów
 */
Poly PolyCloneMonos(size_t count, const Mono monos[]);
</code></pre>

<p>Przy implementowaniu tych funkcji należy unikać powtarzania kodu.</p>

<p>Użyte w poniższych przykładach makra <code>C</code> i <code>P</code> oraz funkcja <code>M</code> są zdefiniowane
w testach do części 1 zadania, w pliku <code>poly_test.c</code>.</p>

<h4>Przykład 1</h4>

<p>Funkcja <code>PolyOwnMonos</code> przejmuje na własność zarówno zawartość tablicy <code>monos</code>,
jak i pamięć zajmowaną przez tę tablicę.
Wywołanie funkcji <code>PolyDestroy</code> musi zwolnić wszystkie zasoby.</p>

<pre><code class="C">Mono *monos = calloc(2, sizeof (Mono));
assert(monos);
monos[0] = M(P(C(-1), 1), 1);
monos[1] = M(P(C(1), 1), 2);
Poly p = PolyOwnMonos(2, monos);
PolyDestroy(&amp;p);
</code></pre>

<h4>Przykład 2</h4>

<p>Funkcja <code>PolyCloneMonos</code> nie przejmuje na własność żadnych zasobów i nie
modyfikuje zawartości tablicy <code>monos</code>.
Utworzone wielomiany <code>p1</code> i <code>p2</code> są takie same.
Oprócz wywołań funkcji <code>PolyDestroy</code> konieczne są wywołania
funkcji <code>MonoDestroy</code> i zwolnienie pamięci za pomocą funkcji <code>free</code>.</p>

<pre><code class="C">Mono *monos = calloc(2, sizeof (Mono));
assert(monos);
monos[0] = M(P(C(-1), 1), 1);
monos[1] = M(P(C(1), 1), 2);
Poly p1 = PolyCloneMonos(2, monos);
Poly p2 = PolyCloneMonos(2, monos);
PolyDestroy(&amp;p1);
PolyDestroy(&amp;p2);
MonoDestroy(monos + 0);
MonoDestroy(monos + 1);
free(monos);
</code></pre>

<h3>Składanie wielomianów</h3>

<p>Definiujemy operację składania wielomianów.
Dany jest wielomian $p$ oraz $k$ wielomianów $q_0$, $q_1$, $q_2$, $…$, $q_{k-1}$.
Niech $l$ oznacza liczbę zmiennych wielomianu $p$ i niech te zmienne są
oznaczone odpowiednio $x_0$, $x_1$, $x_2$, $…$, $x_{l-1}$.
Wynikiem złożenia jest wielomian $p(q_0, q_1, q_2, …)$, czyli wielomian
powstający przez podstawienie w wielomianie $p$ pod zmienną $x_i$ wielomianu
$q_i$ dla $i = 0, 1, 2, …, \min(k, l) - 1$.
Jeśli $k&lt;l$, to pod zmienne $x_k$, $…$, $x_{l-1}$ podstawiamy zera.
Na przykład, jeśli $k=0$, to wynikiem złożenia jest liczba $p(0, 0, 0, …)$.</p>

<p>W celu realizacji operacji składanie wielomianów należy rozszerzyć bibliotekę
<code>poly</code> o funkcję</p>

<pre><code class="C">Poly PolyCompose(const Poly *p, size_t k, const Poly q[]);
</code></pre>

<p>Do interfejsu kalkulatora należy dodać polecenie</p>

<pre><code>COMPOSE k
</code></pre>

<p>Polecenie to zdejmuje z wierzchołka stosu najpierw wielomian <code>p</code>, a potem
kolejno wielomiany <code>q[k - 1]</code>, <code>q[k - 2]</code>, $…$, <code>q[0]</code> i umieszcza na stosie
wynik operacji złożenia.</p>

<p>Jeśli w poleceniu <code>COMPOSE</code> nie podano parametru lub jest on niepoprawny,
program powinien wypisać na standardowe wyjście diagnostyczne:</p>

<pre><code>ERROR w COMPOSE WRONG PARAMETER\n
</code></pre>

<p>Wartość parametru polecenia <code>COMPOSE</code> uznajemy za niepoprawną, jeśli jest
mniejsza od <code>0</code> lub większa od <code>18446744073709551615</code>.</p>

<p>Jeśli na stosie jest za mało wielomianów, aby wykonać polecenie, program
powinien wypisać na standardowe wyjście diagnostyczne:</p>

<pre><code>ERROR w STACK UNDERFLOW\n
</code></pre>

<p>Jak poprzednio w obu przypadkach <code>w</code> oznacza numer wiersza, a <code>\n</code> – znak
przejścia do nowego wiersza.</p>

<h4>Przykład 1</h4>

<p>Dla danych wejściowych:</p>

<pre><code>(1,2)
(2,0)+(1,1)
COMPOSE 1
PRINT
(1,3)
COMPOSE 1
PRINT
</code></pre>

<p>Jako wynik działania programu powinniśmy zobaczyć:</p>

<pre><code>(2,0)+(1,2)
(8,0)+(12,2)+(6,4)+(1,6)
</code></pre>

<p>Wyjaśnienie do przykładu:</p>

<ul>
<li>Pierwsze polecenie <code>COMPOSE</code> podstawia wielomian $x_0^2$ pod $x_0$ w wielomianie $\left(2+x_0\right)$,
więc w jego wyniku otrzymujemy wielomian $\left(2+x_0^2\right)$.</li>
<li>Drugie polecenie <code>COMPOSE</code> podstawia wielomian $\left(2+x_0^2\right)$ pod $x_0$ w wielomianie $x_0^3$,
więc w jego wyniku otrzymujemy wielomian $\left(8+12x_0^2+6x_0^4+x_0^6\right)$.</li>
</ul>

<h4>Przykład 2</h4>

<p>Dla danych wejściowych:</p>

<pre><code>(1,4)
((1,0)+(1,1),1)
(((1,6),5),2)+((1,0)+(1,2),3)+(5,7)
COMPOSE 2
PRINT
</code></pre>

<p>Jako wynik działania programu powinniśmy zobaczyć:</p>

<pre><code>(1,12)+((1,0)+(2,1)+(1,2),14)+(5,28)
</code></pre>

<p>Wyjaśnienie do przykładu:</p>

<p>Polecenie <code>COMPOSE</code> podstawia do wielomianu $p = x_2^6 x_1^5 x_0^2 + \left(1 + x_1^2\right) x_0^3 + 5 x_0^7$:</p>

<ul>
<li>wielomian $x_0^4$ pod $x_0$,</li>
<li>wielomian $\left(1 + x_1\right) x_0$ pod $x_1$,</li>
<li>0 pod $x_2$.</li>
</ul>

<p>W rezultacie:</p>

<ul>
<li>wyraz $x_2^6 x_1^5 x_0^2$ przechodzi w $0$,</li>
<li>wyraz $\left(1 + x_1^2\right)$ przechodzi w $\left(1 + \left(1 + 2x_1 + x_1^2\right) x_0^2\right)$,</li>
<li>wyraz $x_0^3$ przechodzi w $x_0^{12}$,</li>
<li>wyraz $5 x_0^7$ przechodzi w $5 x_0^{28}$.</li>
</ul>

<p>Zatem cały wielomian $p$ przechodzi w wielomian:</p>

<p>$0 + \left(1 + \left(1 + 2x_1 + x_1^2\right) x_0^2\right) x_0^{12} + 5 x_0^{28}
= x_0^{12} + \left(1 + 2x_1 + x_1^2\right) x_0^{14} + 5 x_0^{28}$.</p>

<h4>Przykład 3</h4>

<p>Dla danych wejściowych:</p>

<pre><code>((1,0)+(1,1),1)
(1,4)
COMPOSE -1
COMPOSE 18446744073709551615
</code></pre>

<p>Jako wynik działania programu powinniśmy zobaczyć:</p>

<pre><code>ERROR 3 COMPOSE WRONG PARAMETER
ERROR 4 STACK UNDERFLOW
</code></pre>

<h3>Dokumentacja</h3>

<p>Dodany kod należy udokumentować w formacie <code>doxygen</code>.</p>

<h3>Modyfikacja skryptu budującego</h3>

<p>Należy dodać możliwość utworzenia pliku wykonywalnego z testami biblioteki <code>poly</code>.
Czyli na przykład po wykonaniu:</p>

<pre><code class="sh">mkdir release
cd release
cmake ..
</code></pre>

<ul>
<li>polecenie <code>make</code> tworzy plik wykonywalny <code>poly</code> całego kalkulatora,</li>
<li>polecenie <code>make test</code> tworzy plik wykonywalny <code>poly_test</code> z testami biblioteki <code>poly</code>,</li>
<li>polecenie <code>make doc</code> tworzy dokumentację w formacie <code>doxygen</code>.</li>
</ul>

<p>Funkcja <code>main</code> kalkulatora ma się znajdować w pliku <code>src/calc.c</code>.
Funkcja <code>main</code> uruchamiająca testy biblioteki <code>poly</code> ma się znajdować w pliku
<code>src/poly_test.c</code> – może to być plik z udostępnionymi testami do części 1
zadania i rozszerzony o własne testy. Zawartość tego pliku nie będzie oceniana.</p>

<p>Wskazówka:
W pliku <code>CMakeList.txt</code> można dodać polecenia</p>

<pre><code># Wskazujemy plik wykonywalny testów biblioteki.
add_executable(test EXCLUDE_FROM_ALL ${TEST_SOURCE_FILES})
set_target_properties(test PROPERTIES OUTPUT_NAME poly_test)
</code></pre>

<p>definiując uprzednio zmienną <code>TEST_SOURCE_FILES</code>.</p>

<h3>Wymagania</h3>

<p>Rozwiązanie części 3 zadania powinno korzystać z własnego rozwiązania
poprzednich jego części.
Obowiązują wszystkie wymagania z poprzednich części zadania, jeśli nie zostały
zmienione w tym dokumencie.</p>

<p><strong>Uwaga: niezmiernie istotne jest, aby przestrzegać opisanej specyfikacji nazw plików.</strong></p>
